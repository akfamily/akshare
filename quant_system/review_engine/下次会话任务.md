# 下次会话任务清单

## 📊 当前进度（已完成30%）

### ✅ 第一阶段：架构与数据层（已完成）

1. **项目架构** ✅
   - 完整的目录结构
   - 模块化设计（providers/core/reporting/integrations）

2. **配置系统** ✅
   - config.yaml（权重、规则、ETF分组、行业轮动配置）
   - .env.example（环境变量）
   - 完整的配置文档

3. **数据层基础** ✅
   - AkShareProvider类框架
   - SQLite数据库设计（9张表）
   - 数据校验机制
   - 错误处理与重试
   - 已实现接口：
     - ✅ 指数数据（上证/深成/创业板/沪深300）
     - ✅ 成交额
     - ✅ 市场广度（涨跌家数、涨跌停）
     - ✅ 北向资金

### 🚧 第二阶段：完善数据接口（下次会话优先）

**目标**：完成所有AkShare数据接口，确保零虚拟数据

#### 1. ETF流向（重要！）
```python
def fetch_etf_flows(self, date: str, bucket: str) -> Dict:
    """
    获取ETF分组的净流向

    实现方式：
    1. 使用 ak.fund_etf_fund_info_em() 获取份额数据
    2. 计算份额变化作为净流向代理
    3. 按config.yaml中的分组聚合

    分组配置：
    - broad: ["510300", "510500", "159915"]
    - growth: ["159949", "159915"]
    - value: ["510880", "510900"]
    - industry_resources: ["510170", "159980"]
    - industry_tech: ["159801", "159841"]
    """
    pass
```

#### 2. 融资融券余额
```python
def fetch_margin(self, date: str) -> Dict:
    """
    获取两市融资融券余额

    实现方式：
    1. ak.stock_margin_sse() 沪市
    2. ak.stock_margin_szse() 深市
    3. 合并计算总余额
    """
    pass
```

#### 3. 行业数据聚合
```python
def fetch_industry_data(self, date: str) -> pd.DataFrame:
    """
    聚合行业级别数据

    数据来源：
    1. 从 ak.stock_zh_a_spot_em() 获取个股数据
    2. 按"行业"字段分组
    3. 计算：
       - avg_return: 行业平均涨跌幅
       - net_flow: 行业主力净流入合计
       - avg_turnover: 行业平均换手率
       - limit_up_count: 涨停家数（从涨停池分组）

    注意：需要处理行业字段的多种名称
    """
    pass
```

#### 4. 宏观数据
```python
def fetch_macro_data(self, date: str) -> Dict:
    """
    获取宏观代理指标

    数据源：
    1. PMI: ak.macro_china_pmi()
       - 取"新订单指数"
       - 取"产成品库存"

    2. PPI: ak.macro_china_ppi()
       - 取同比（若无环比）

    3. 大宗商品: ak.macro_china_commodity_index()
       - 或自定义大宗篮子收益
    """
    pass
```

#### 5. Parquet持久化
```python
def save_to_parquet(self, table_name: str, df: pd.DataFrame):
    """
    保存时间序列数据到Parquet

    优势：
    - 快速读写
    - 支持回测
    - 列式存储节省空间
    """
    pass
```

#### 6. 连板持续率（需多日数据）
```python
def calculate_continuous_limit_rate(self, date: str, lookback: int = 20) -> float:
    """
    计算连板持续率

    逻辑：
    1. 从SQLite读取过去lookback日的涨停池数据
    2. 统计：昨日连板标的 → 今日上涨的比例
    3. 返回持续率

    注意：首次运行需要历史数据积累
    """
    pass
```

---

## 📝 第三阶段：核心计算模块

### 1. 因子计算（core/factors.py）

**目标**：实现多周期趋势因子

```python
"""
因子计算模块

核心功能：
1. 多周期EMA（5/10/30）
2. 线性斜率（回归β）
3. rolling z-score
4. 趋势标签生成
"""

import pandas as pd
import numpy as np
from typing import Dict, List
from scipy import stats

def compute_multi_horizon(series: pd.Series, windows: List[int] = [5, 10, 30]) -> Dict:
    """
    计算多周期趋势因子

    Args:
        series: 时间序列（如成交额、北向资金）
        windows: 窗口列表

    Returns:
        {
            5: {ema: float, slope: float, z: float},
            10: {...},
            30: {...}
        }
    """
    results = {}

    for w in windows:
        # 1. EMA
        ema = series.ewm(span=w).mean().iloc[-1]

        # 2. 线性回归斜率
        x = np.arange(w)
        y = series.iloc[-w:].values
        slope, intercept, r_value, p_value, std_err = stats.linregress(x, y)

        # 3. z-score（基于更长窗口max(10, w)）
        z_window = max(10, w)
        mean = series.iloc[-z_window:].mean()
        std = series.iloc[-z_window:].std()
        z_score = (series.iloc[-1] - mean) / std if std > 0 else 0

        results[w] = {
            'ema': ema,
            'slope': slope,
            'z': z_score
        }

    return results

def trend_label(trends_dict: Dict) -> str:
    """
    生成趋势标签

    Args:
        trends_dict: compute_multi_horizon的输出

    Returns:
        趋势描述（如"多周期共振上行"）
    """
    slopes = [v['slope'] for v in trends_dict.values()]

    # 多周期共振判断
    all_up = all(s > 0 for s in slopes)
    all_down = all(s < 0 for s in slopes)

    if all_up:
        return "多周期共振上行"
    elif all_down:
        return "多周期共振走弱"
    elif slopes[0] > 0 and slopes[1] > 0:
        return "短中上行、长未修复"
    elif slopes[0] > 0:
        return "短修复、长偏弱"
    else:
        return "分化震荡"
```

---

### 2. 评分系统（core/scoring.py）

**目标**：四维评分 → 总分

```python
"""
评分系统

四维评分：
1. Macro（25%）
2. Liquidity（35%）
3. Risk-on（20%）
4. Momentum（20%）
"""

def score_liquidity(trends: Dict, config: dict) -> float:
    """
    流动性评分（0-100）

    输入：
    - 成交额多周期趋势
    - 北向资金多周期趋势
    - ETF分组流向
    - 融资余额趋势

    逻辑：
    1. 对每个序列的slope和z-score归一化到0-100
    2. 按权重加权
    3. 返回综合得分
    """
    pass

def score_riskon(breadth_data: Dict, config: dict) -> float:
    """
    Risk-on评分（0-100）

    输入：
    - 连板高度
    - 涨停/跌停比
    - 连板持续率

    逻辑：
    1. 计算各指标的z-score
    2. 归一化到0-100
    3. 加权合成
    """
    pass

def score_momentum(indices_trends: Dict, amount_trends: Dict) -> float:
    """
    动量评分（0-100）

    输入：
    - 宽基指数动量（5/10/30斜率）
    - 成交额趋势
    """
    pass

def score_macro(pmi: Dict, ppi: float, commodity: float) -> float:
    """
    宏观评分（0-100）

    输入：
    - PMI新订单/库存 → 基钦周期四象限
    - PPI
    - 大宗商品收益

    逻辑：
    1. 四象限映射到评分
    2. 结合PPI和大宗商品调节
    """
    pass

def total_score(scores: Dict, weights: Dict) -> float:
    """
    合成总分

    Args:
        scores: {macro: xx, liquidity: xx, riskon: xx, momentum: xx}
        weights: {macro: 0.25, liquidity: 0.35, ...}

    Returns:
        总分（0-100）
    """
    return sum(scores[k] * weights[k] for k in scores)
```

---

### 3. 行业轮动与配置（core/allocation.py）

```python
"""
资产配置模块

包含：
1. 行业轮动矩阵
2. 仓位/风格决策
3. 行业超/低配选择
"""

def rotation_map(industry_df: pd.DataFrame, config: dict) -> pd.DataFrame:
    """
    行业轮动矩阵

    输入：
    - industry_df: 行业数据（avg_return, net_flow, avg_turnover, limit_up_count）

    输出：
    - DataFrame: [industry, strength, crowding, quadrant, recommendation]

    逻辑：
    1. 强度 = 0.6 * return_percentile + 0.4 * net_flow_percentile
    2. 拥挤度 = 0.6 * turnover_percentile + 0.4 * limit_up_percentile
    3. 四象限分类
    4. 生成建议（超配/标配/低配）
    """
    pass

def decide_allocation(total_score: float, config: dict) -> Dict:
    """
    决定仓位和风格

    输入：
    - total_score: 总分（0-100）
    - config: allocation_rules

    输出：
    - {position: 65, style: "均衡/轻偏顺周期"}
    """
    for rule in config['allocation_rules']:
        if rule['score_min'] <= total_score < rule['score_max']:
            # 线性插值计算仓位
            ratio = (total_score - rule['score_min']) / (rule['score_max'] - rule['score_min'])
            position = rule['position_min'] + ratio * (rule['position_max'] - rule['position_min'])

            return {
                'position': int(position),
                'style': rule['style']
            }

    return {'position': 50, 'style': '均衡'}

def pick_industries(rotation_df: pd.DataFrame) -> Dict:
    """
    选择超配/低配行业

    逻辑：
    1. 超配：quadrant="首选" 且 crowding<0.7 的Top3
    2. 低配：quadrant="回避" 的Top3
    3. 其余为标配
    """
    pass
```

---

### 4. 报告生成（reporting/renderer.py）

```python
"""
报告生成器

输出：
1. Markdown文本报告
2. JSON结构化数据
3. 图表（可选）
"""

def generate_markdown(data: Dict) -> str:
    """
    生成Markdown报告

    结构：
    # 今日市场复盘（YYYY-MM-DD）

    ## 摘要
    - 总分：XX
    - 仓位：XX%
    - 风格：XX

    ## 量能与资金
    ### 成交额
    - 短期（5日）：趋势标签，EMA=XX，斜率=XX
    - ...

    ### 北向资金
    - ...

    ## 四维评分
    | 维度 | 得分 | 权重 |
    |------|------|------|
    | Macro | XX | 25% |
    | ...

    ## 行业轮动
    | 行业 | 强度 | 拥挤度 | 象限 | 建议 |
    | ... |

    ## 三段式收束
    ### 利好
    - ...

    ### 利空
    - ...

    ### 结论
    仓位XX%，操作XX，风格XX，行业（超配XX，低配XX），风险提示XX
    """
    pass

def generate_json(data: Dict) -> Dict:
    """
    生成结构化JSON

    格式见PRD第8节
    """
    pass
```

---

### 5. 主程序（run_daily.py）

```python
"""
主程序

运行完整的日度复盘流程
"""

import yaml
from datetime import datetime
from providers.akshare_provider import AkShareProvider
from core.factors import compute_multi_horizon, trend_label
from core.scoring import *
from core.allocation import *
from reporting.renderer import *

def run_daily_review(date: str = None, config_path: str = 'config/config.yaml'):
    """
    运行日度复盘

    Args:
        date: 日期（YYYY-MM-DD），默认今日
        config_path: 配置文件路径
    """
    # 1. 加载配置
    with open(config_path) as f:
        config = yaml.safe_load(f)

    # 2. 初始化数据提供者
    provider = AkShareProvider(config)

    # 3. 拉取数据
    provider.fetch_and_save_all(date)

    # 4. 计算因子
    # ...

    # 5. 计算评分
    # ...

    # 6. 决定配置
    # ...

    # 7. 生成报告
    # ...

    # 8. 输出
    print(markdown_report)
    with open(f'output/review_{date}.json', 'w') as f:
        json.dump(json_data, f, ensure_ascii=False, indent=2)

if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('--date', default=None)
    parser.add_argument('--export', default='output/')
    args = parser.parse_args()

    run_daily_review(args.date)
```

---

## 🎯 下次会话目标

### 必须完成：
1. ✅ 完善数据提供者（ETF、融资融券、行业、宏观、Parquet）
2. ✅ 实现因子计算模块
3. ✅ 实现评分系统
4. ✅ 实现配置决策
5. ✅ 实现报告生成
6. ✅ 创建主程序
7. ✅ 编写验收测试

### 可选完成：
- DeepSeek接口（带开关）
- 图表生成
- Web界面集成

---

## 📋 验收标准（必须全过）

1. **零模拟数据**：代码中不得出现`random`、`np.random`等
2. **数据完整性**：所有表都有数据，无全NaN列
3. **多周期**：输出JSON包含5/10/30的ema/slope/z
4. **评分**：四维+总分全在0-100
5. **配置**：仓位在20-90%
6. **报告**：包含利好/利空/结论三段
7. **持久化**：SQLite有9张表，Parquet目录非空
8. **错误处理**：失败时有清晰的错误信息

---

**当前版本**：0.1.0（架构与数据层）
**下次目标**：0.5.0（MVP可运行版本）
**最终目标**：1.0.0（完整PRD实现）
